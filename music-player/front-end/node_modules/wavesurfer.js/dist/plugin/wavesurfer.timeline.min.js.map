{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///wavesurfer.timeline.min.js","webpack:///webpack/bootstrap 2e5ff4b2126b5af12ddc","webpack:///./src/plugin/timeline.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","6","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","TimelinePlugin","params","ws","_this","container","document","querySelector","Error","wavesurfer","util","extend","height","notchPercentHeight","primaryColor","secondaryColor","primaryFontColor","secondaryFontColor","fontFamily","fontSize","formatTimeCallback","seconds","minutes","parseInt","timeInterval","pxPerSec","primaryLabelInterval","secondaryLabelInterval","canvases","_onScroll","wrapper","scrollLeft","drawer","_onRedraw","render","_onReady","pixelRatio","maxCanvasWidth","width","maxCanvasElementWidth","Math","round","createWrapper","addEventListener","on","deferInit","isReady","unAll","un","removeEventListener","parentNode","removeChild","_this2","wsParams","appendChild","createElement","style","display","position","userSelect","webkitUserSelect","fillParent","scrollParent","overflowX","overflowY","_onClick","e","preventDefault","relX","offsetX","layerX","fireEvent","scrollWidth","canvas","pop","parentElement","removeOldCanvases","totalWidth","requiredCanvases","ceil","push","zIndex","createCanvases","updateCanvasStyle","drawTimeCanvases","canvasWidth","left","backend","duration","getDuration","totalSeconds","getWidth","pixelsPerSecond","formatTime","intervalFnOrVal","option","curPixel","curSeconds","height1","height2","setFillStyles","fillRect","setFonts","fillText","fillStyle","forEach","getContext","font","x","y","_this3","leftOffset","intersection","x1","max","y1","x2","min","y2","text","textWidth","xOffset","context","measureText","default"],"mappings":"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","file":"wavesurfer.timeline.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"timeline\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"timeline\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"timeline\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"timeline\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"timeline\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"timeline\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"localhost:8080/dist/plugin/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 6:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {function} formatTimeCallback=→00:00\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nvar TimelinePlugin = function () {\n    _createClass(TimelinePlugin, null, [{\n        key: 'create',\n\n        /**\n         * Timeline plugin definition factory\n         *\n         * This function must be used to create a plugin definition which can be\n         * used by wavesurfer to correctly instantiate the plugin.\n         *\n         * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n         * @return {PluginDefinition} an object representing the plugin\n         */\n        value: function create(params) {\n            return {\n                name: 'timeline',\n                deferInit: params && params.deferInit ? params.deferInit : false,\n                params: params,\n                instance: TimelinePlugin\n            };\n        }\n    }]);\n\n    function TimelinePlugin(params, ws) {\n        var _this = this;\n\n        _classCallCheck(this, TimelinePlugin);\n\n        this.container = 'string' == typeof params.container ? document.querySelector(params.container) : params.container;\n\n        if (!this.container) {\n            throw new Error('No container for wavesurfer timeline');\n        }\n        this.wavesurfer = ws;\n        this.util = ws.util;\n        this.params = this.util.extend({}, {\n            height: 20,\n            notchPercentHeight: 90,\n            primaryColor: '#000',\n            secondaryColor: '#c0c0c0',\n            primaryFontColor: '#000',\n            secondaryFontColor: '#000',\n            fontFamily: 'Arial',\n            fontSize: 10,\n            formatTimeCallback: function formatTimeCallback(seconds) {\n                if (seconds / 60 > 1) {\n                    // calculate minutes and seconds from seconds count\n                    var minutes = parseInt(seconds / 60, 10);\n                    seconds = parseInt(seconds % 60, 10);\n                    // fill up seconds with zeroes\n                    seconds = seconds < 10 ? '0' + seconds : seconds;\n                    return minutes + ':' + seconds;\n                }\n                return seconds;\n            },\n            timeInterval: function timeInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 1;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 5;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 15;\n                }\n                return 60;\n            },\n            primaryLabelInterval: function primaryLabelInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 10;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 6;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 4;\n                }\n                return 4;\n            },\n            secondaryLabelInterval: function secondaryLabelInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 5;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 2;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 2;\n                }\n                return 2;\n            }\n        }, params);\n\n        this.canvases = [];\n\n        this._onScroll = function () {\n            _this.wrapper.scrollLeft = _this.drawer.wrapper.scrollLeft;\n        };\n        this._onRedraw = function () {\n            return _this.render();\n        };\n        this._onReady = function () {\n            _this.drawer = ws.drawer;\n            _this.pixelRatio = ws.drawer.params.pixelRatio;\n            _this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n            _this.maxCanvasElementWidth = ws.drawer.maxCanvasElementWidth || Math.round(_this.maxCanvasWidth / _this.pixelRatio);\n\n            _this.createWrapper();\n            _this.render();\n            ws.drawer.wrapper.addEventListener('scroll', _this._onScroll);\n            ws.on('redraw', _this._onRedraw);\n        };\n    }\n\n    _createClass(TimelinePlugin, [{\n        key: 'init',\n        value: function init() {\n            this.wavesurfer.on('ready', this._onReady);\n            // Check if ws is ready\n            if (this.wavesurfer.isReady) {\n                this._onReady();\n            }\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this.unAll();\n            this.wavesurfer.un('redraw', this._onRedraw);\n            this.wavesurfer.un('ready', this._onReady);\n            this.wavesurfer.drawer.wrapper.removeEventListener('scroll', this._onScroll);\n            if (this.wrapper && this.wrapper.parentNode) {\n                this.wrapper.parentNode.removeChild(this.wrapper);\n                this.wrapper = null;\n            }\n        }\n    }, {\n        key: 'createWrapper',\n        value: function createWrapper() {\n            var _this2 = this;\n\n            var wsParams = this.wavesurfer.params;\n            this.wrapper = this.container.appendChild(document.createElement('timeline'));\n            this.util.style(this.wrapper, {\n                display: 'block',\n                position: 'relative',\n                userSelect: 'none',\n                webkitUserSelect: 'none',\n                height: this.params.height + 'px'\n            });\n\n            if (wsParams.fillParent || wsParams.scrollParent) {\n                this.util.style(this.wrapper, {\n                    width: '100%',\n                    overflowX: 'hidden',\n                    overflowY: 'hidden'\n                });\n            }\n\n            this._onClick = function (e) {\n                e.preventDefault();\n                var relX = 'offsetX' in e ? e.offsetX : e.layerX;\n                _this2.fireEvent('click', relX / _this2.wrapper.scrollWidth || 0);\n            };\n            this.wrapper.addEventListener('click', this._onClick);\n        }\n    }, {\n        key: 'removeOldCanvases',\n        value: function removeOldCanvases() {\n            while (this.canvases.length > 0) {\n                var canvas = this.canvases.pop();\n                canvas.parentElement.removeChild(canvas);\n            }\n        }\n    }, {\n        key: 'createCanvases',\n        value: function createCanvases() {\n            this.removeOldCanvases();\n\n            var totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n            var requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);\n            var i = void 0;\n\n            for (i = 0; i < requiredCanvases; i++) {\n                var canvas = this.wrapper.appendChild(document.createElement('canvas'));\n                this.canvases.push(canvas);\n                this.util.style(canvas, {\n                    position: 'absolute',\n                    zIndex: 4\n                });\n            }\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            this.createCanvases();\n            this.updateCanvasStyle();\n            this.drawTimeCanvases();\n        }\n    }, {\n        key: 'updateCanvasStyle',\n        value: function updateCanvasStyle() {\n            var requiredCanvases = this.canvases.length;\n            var i = void 0;\n            for (i = 0; i < requiredCanvases; i++) {\n                var canvas = this.canvases[i];\n                var canvasWidth = this.maxCanvasElementWidth;\n\n                if (i === requiredCanvases - 1) {\n                    canvasWidth = this.drawer.wrapper.scrollWidth - this.maxCanvasElementWidth * (requiredCanvases - 1);\n                }\n\n                canvas.width = canvasWidth * this.pixelRatio;\n                canvas.height = this.params.height * this.pixelRatio;\n                this.util.style(canvas, {\n                    width: canvasWidth + 'px',\n                    height: this.params.height + 'px',\n                    left: i * this.maxCanvasElementWidth + 'px'\n                });\n            }\n        }\n    }, {\n        key: 'drawTimeCanvases',\n        value: function drawTimeCanvases() {\n            var backend = this.wavesurfer.backend;\n            var wsParams = this.wavesurfer.params;\n            var duration = this.wavesurfer.backend.getDuration();\n            var totalSeconds = parseInt(duration, 10) + 1;\n            var width = wsParams.fillParent && !wsParams.scrollParent ? this.drawer.getWidth() : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n            var pixelsPerSecond = width / duration;\n\n            var formatTime = this.params.formatTimeCallback;\n            // if parameter is function, call the function with\n            // pixelsPerSecond, otherwise simply take the value as-is\n            var intervalFnOrVal = function intervalFnOrVal(option) {\n                return typeof option === 'function' ? option(pixelsPerSecond) : option;\n            };\n            var timeInterval = intervalFnOrVal(this.params.timeInterval);\n            var primaryLabelInterval = intervalFnOrVal(this.params.primaryLabelInterval);\n            var secondaryLabelInterval = intervalFnOrVal(this.params.secondaryLabelInterval);\n\n            var curPixel = 0;\n            var curSeconds = 0;\n\n            if (duration <= 0) {\n                return;\n            }\n\n            var height1 = this.params.height - 4;\n            var height2 = this.params.height * (this.params.notchPercentHeight / 100) - 4;\n            var fontSize = this.params.fontSize * wsParams.pixelRatio;\n            var i = void 0;\n\n            for (i = 0; i < totalSeconds / timeInterval; i++) {\n                if (i % primaryLabelInterval == 0) {\n                    this.setFillStyles(this.params.primaryColor);\n                    this.fillRect(curPixel, 0, 1, height1);\n                    this.setFonts(fontSize + 'px ' + this.params.fontFamily);\n                    this.setFillStyles(this.params.primaryFontColor);\n                    this.fillText(formatTime(curSeconds), curPixel + 5, height1);\n                } else if (i % secondaryLabelInterval == 0) {\n                    this.setFillStyles(this.params.secondaryColor);\n                    this.fillRect(curPixel, 0, 1, height1);\n                    this.setFonts(fontSize + 'px ' + this.params.fontFamily);\n                    this.setFillStyles(this.params.secondaryFontColor);\n                    this.fillText(formatTime(curSeconds), curPixel + 5, height1);\n                } else {\n                    this.setFillStyles(this.params.secondaryColor);\n                    this.fillRect(curPixel, 0, 1, height2);\n                }\n\n                curSeconds += timeInterval;\n                curPixel += pixelsPerSecond * timeInterval;\n            }\n        }\n    }, {\n        key: 'setFillStyles',\n        value: function setFillStyles(fillStyle) {\n            this.canvases.forEach(function (canvas) {\n                canvas.getContext('2d').fillStyle = fillStyle;\n            });\n        }\n    }, {\n        key: 'setFonts',\n        value: function setFonts(font) {\n            this.canvases.forEach(function (canvas) {\n                canvas.getContext('2d').font = font;\n            });\n        }\n    }, {\n        key: 'fillRect',\n        value: function fillRect(x, y, width, height) {\n            var _this3 = this;\n\n            this.canvases.forEach(function (canvas, i) {\n                var leftOffset = i * _this3.maxCanvasWidth;\n\n                var intersection = {\n                    x1: Math.max(x, i * _this3.maxCanvasWidth),\n                    y1: y,\n                    x2: Math.min(x + width, i * _this3.maxCanvasWidth + canvas.width),\n                    y2: y + height\n                };\n\n                if (intersection.x1 < intersection.x2) {\n                    canvas.getContext('2d').fillRect(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1);\n                }\n            });\n        }\n    }, {\n        key: 'fillText',\n        value: function fillText(text, x, y) {\n            var textWidth = void 0;\n            var xOffset = 0;\n            var i = void 0;\n\n            for (i in this.canvases) {\n                var context = this.canvases[i].getContext('2d');\n                var canvasWidth = context.canvas.width;\n\n                if (xOffset > x + textWidth) {\n                    break;\n                }\n\n                if (xOffset + canvasWidth > x) {\n                    textWidth = context.measureText(text).width;\n                    context.fillText(text, x - xOffset, y);\n                }\n\n                xOffset += canvasWidth;\n            }\n        }\n    }]);\n\n    return TimelinePlugin;\n}();\n\nexports.default = TimelinePlugin;\nmodule.exports = exports['default'];\n\n/***/ })\n\n/******/ });\n});\n\n\n// WEBPACK FOOTER //\n// wavesurfer.timeline.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"localhost:8080/dist/plugin/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2e5ff4b2126b5af12ddc","/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {function} formatTimeCallback=→00:00\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class TimelinePlugin {\n    /**\n     * Timeline plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n     * @return {PluginDefinition} an object representing the plugin\n     */\n    static create(params) {\n        return {\n            name: 'timeline',\n            deferInit: params && params.deferInit ? params.deferInit : false,\n            params: params,\n            instance: TimelinePlugin\n        };\n    }\n\n    constructor(params, ws) {\n        this.container = 'string' == typeof params.container\n            ? document.querySelector(params.container)\n            : params.container;\n\n        if (!this.container) {\n            throw new Error('No container for wavesurfer timeline');\n        }\n        this.wavesurfer = ws;\n        this.util = ws.util;\n        this.params = this.util.extend({}, {\n            height: 20,\n            notchPercentHeight: 90,\n            primaryColor: '#000',\n            secondaryColor: '#c0c0c0',\n            primaryFontColor: '#000',\n            secondaryFontColor: '#000',\n            fontFamily: 'Arial',\n            fontSize: 10,\n            formatTimeCallback(seconds) {\n                if (seconds / 60 > 1) {\n                    // calculate minutes and seconds from seconds count\n                    const minutes = parseInt(seconds / 60, 10);\n                    seconds = parseInt(seconds % 60, 10);\n                    // fill up seconds with zeroes\n                    seconds = (seconds < 10) ? '0' + seconds : seconds;\n                    return `${minutes}:${seconds}`;\n                }\n                return seconds;\n            },\n            timeInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 1;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 5;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 15;\n                }\n                return 60;\n            },\n            primaryLabelInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 10;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 6;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 4;\n                }\n                return 4;\n            },\n            secondaryLabelInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 5;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 2;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 2;\n                }\n                return 2;\n            }\n        }, params);\n\n        this.canvases = [];\n\n        this._onScroll = () => {\n            this.wrapper.scrollLeft = this.drawer.wrapper.scrollLeft;\n        };\n        this._onRedraw = () => this.render();\n        this._onReady = () => {\n            this.drawer = ws.drawer;\n            this.pixelRatio = ws.drawer.params.pixelRatio;\n            this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n            this.maxCanvasElementWidth = ws.drawer.maxCanvasElementWidth || Math.round(this.maxCanvasWidth / this.pixelRatio);\n\n            this.createWrapper();\n            this.render();\n            ws.drawer.wrapper.addEventListener('scroll', this._onScroll);\n            ws.on('redraw', this._onRedraw);\n        };\n    }\n\n    init() {\n        this.wavesurfer.on('ready', this._onReady);\n        // Check if ws is ready\n        if (this.wavesurfer.isReady) {\n            this._onReady();\n        }\n    }\n\n    destroy() {\n        this.unAll();\n        this.wavesurfer.un('redraw', this._onRedraw);\n        this.wavesurfer.un('ready', this._onReady);\n        this.wavesurfer.drawer.wrapper.removeEventListener('scroll', this._onScroll);\n        if (this.wrapper && this.wrapper.parentNode) {\n            this.wrapper.parentNode.removeChild(this.wrapper);\n            this.wrapper = null;\n        }\n    }\n\n    createWrapper() {\n        const wsParams = this.wavesurfer.params;\n        this.wrapper = this.container.appendChild(\n            document.createElement('timeline')\n        );\n        this.util.style(this.wrapper, {\n            display: 'block',\n            position: 'relative',\n            userSelect: 'none',\n            webkitUserSelect: 'none',\n            height: `${this.params.height}px`\n        });\n\n        if (wsParams.fillParent || wsParams.scrollParent) {\n            this.util.style(this.wrapper, {\n                width: '100%',\n                overflowX: 'hidden',\n                overflowY: 'hidden'\n            });\n        }\n\n        this._onClick = e => {\n            e.preventDefault();\n            const relX = 'offsetX' in e ? e.offsetX : e.layerX;\n            this.fireEvent('click', (relX / this.wrapper.scrollWidth) || 0);\n        };\n        this.wrapper.addEventListener('click', this._onClick);\n    }\n\n    removeOldCanvases() {\n        while (this.canvases.length > 0) {\n            const canvas = this.canvases.pop();\n            canvas.parentElement.removeChild(canvas);\n        }\n    }\n\n    createCanvases() {\n        this.removeOldCanvases();\n\n        const totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n        const requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);\n        let i;\n\n        for (i = 0; i < requiredCanvases; i++) {\n            const canvas = this.wrapper.appendChild(document.createElement('canvas'));\n            this.canvases.push(canvas);\n            this.util.style(canvas, {\n                position: 'absolute',\n                zIndex: 4\n            });\n        }\n    }\n\n    render() {\n        this.createCanvases();\n        this.updateCanvasStyle();\n        this.drawTimeCanvases();\n    }\n\n    updateCanvasStyle() {\n        const requiredCanvases = this.canvases.length;\n        let i;\n        for (i = 0; i < requiredCanvases; i++) {\n            const canvas = this.canvases[i];\n            let canvasWidth = this.maxCanvasElementWidth;\n\n            if (i === requiredCanvases - 1) {\n                canvasWidth = this.drawer.wrapper.scrollWidth - (this.maxCanvasElementWidth * (requiredCanvases - 1));\n            }\n\n            canvas.width = canvasWidth * this.pixelRatio;\n            canvas.height = this.params.height * this.pixelRatio;\n            this.util.style(canvas, {\n                width: `${canvasWidth}px`,\n                height: `${this.params.height}px`,\n                left: `${i * this.maxCanvasElementWidth}px`\n            });\n        }\n    }\n\n    drawTimeCanvases() {\n        const backend = this.wavesurfer.backend;\n        const wsParams = this.wavesurfer.params;\n        const duration = this.wavesurfer.backend.getDuration();\n        const totalSeconds = parseInt(duration, 10) + 1;\n        const width = wsParams.fillParent && !wsParams.scrollParent\n            ? this.drawer.getWidth()\n            : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n        const pixelsPerSecond = width / duration;\n\n        const formatTime = this.params.formatTimeCallback;\n        // if parameter is function, call the function with\n        // pixelsPerSecond, otherwise simply take the value as-is\n        const intervalFnOrVal = option => (typeof option === 'function' ? option(pixelsPerSecond) : option);\n        const timeInterval = intervalFnOrVal(this.params.timeInterval);\n        const primaryLabelInterval = intervalFnOrVal(this.params.primaryLabelInterval);\n        const secondaryLabelInterval = intervalFnOrVal(this.params.secondaryLabelInterval);\n\n        let curPixel = 0;\n        let curSeconds = 0;\n\n        if (duration <= 0) {\n            return;\n        }\n\n        const height1 = this.params.height - 4;\n        const height2 = (this.params.height * (this.params.notchPercentHeight / 100)) - 4;\n        const fontSize = this.params.fontSize * wsParams.pixelRatio;\n        let i;\n\n        for (i = 0; i < totalSeconds / timeInterval; i++) {\n            if (i % primaryLabelInterval == 0) {\n                this.setFillStyles(this.params.primaryColor);\n                this.fillRect(curPixel, 0, 1, height1);\n                this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n                this.setFillStyles(this.params.primaryFontColor);\n                this.fillText(formatTime(curSeconds), curPixel + 5, height1);\n            } else if (i % secondaryLabelInterval == 0) {\n                this.setFillStyles(this.params.secondaryColor);\n                this.fillRect(curPixel, 0, 1, height1);\n                this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n                this.setFillStyles(this.params.secondaryFontColor);\n                this.fillText(formatTime(curSeconds), curPixel + 5, height1);\n            } else {\n                this.setFillStyles(this.params.secondaryColor);\n                this.fillRect(curPixel, 0, 1, height2);\n            }\n\n            curSeconds += timeInterval;\n            curPixel += pixelsPerSecond * timeInterval;\n        }\n    }\n\n    setFillStyles(fillStyle) {\n        this.canvases.forEach(canvas => {\n            canvas.getContext('2d').fillStyle = fillStyle;\n        });\n    }\n\n    setFonts(font) {\n        this.canvases.forEach(canvas => {\n            canvas.getContext('2d').font = font;\n        });\n    }\n\n    fillRect(x, y, width, height) {\n        this.canvases.forEach((canvas, i) => {\n            const leftOffset = i * this.maxCanvasWidth;\n\n            const intersection = {\n                x1: Math.max(x, i * this.maxCanvasWidth),\n                y1: y,\n                x2: Math.min(x + width, i * this.maxCanvasWidth + canvas.width),\n                y2: y + height\n            };\n\n            if (intersection.x1 < intersection.x2) {\n                canvas.getContext('2d').fillRect(\n                    intersection.x1 - leftOffset,\n                    intersection.y1,\n                    intersection.x2 - intersection.x1,\n                    intersection.y2 - intersection.y1\n                );\n            }\n        });\n    }\n\n    fillText(text, x, y) {\n        let textWidth;\n        let xOffset = 0;\n        let i;\n\n        for (i in this.canvases) {\n            const context = this.canvases[i].getContext('2d');\n            const canvasWidth = context.canvas.width;\n\n            if (xOffset > x + textWidth) {\n                break;\n            }\n\n            if (xOffset + canvasWidth > x) {\n                textWidth = context.measureText(text).width;\n                context.fillText(text, x - xOffset, y);\n            }\n\n            xOffset += canvasWidth;\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugin/timeline.js"],"sourceRoot":""}